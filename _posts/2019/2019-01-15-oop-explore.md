---
layout: article
title: 面向对象编程探讨 之 开篇
date: '2019-01-15 18:40:00 +08:00'
key: '2019-01-15_17:03'
tags:
  - Computer Science
---

**Overview**

面向对象编程（Object Oriented Programming， OOP）的威力大家已经有目共睹，以类和对象为核心的抽象方式，可以把生活中绝大部分实体抽象成一个类，能很好的化简实际生活中的各种问题。然而，这只是一种思维范式，程序完全可以在脱离面向对象的情况下被写出来。

本文将从 OOP 的一些机制着手，反推设计者的动机，最终目的是探求并阐述现代的面向对象为何被设计成这种形式，以及何为 OOD ，何为符合 OOD 规范的 OOP 代码。这将是一个系列文章，而此篇就作为该系列的开头。

<!--more-->

## 前言

面向对象编程范式的三大支柱：继承、封装和多态。

借着这三个概念，我们几乎可以将现实世界的一切映射到一个类中去。

但是现代 OOP 编程语言，在围绕着三大支柱发展的同时，加入了大量的修饰。这是因为面向对象并不是那么完美，现实实体的复杂性也不仅仅是一个类能够描述的。

下面，将先从三大支柱的一些缺陷谈起。

## 继承

作为 OOP 最大优势的——继承，可以十分方便的实现代码复用，以及子类对父类功能的扩充。借助继承，我们可以很大程度上避免重复劳动。

这对新手程序员来说相当的重要，因为他们很容易写出只能使用一次的代码。等到遇到相似情况，就会从头再来一遍，但是却只修改了很小的一部分。而继承机制将会引导着他们走向代码复用的道路。

![15-inherit](/images/2019/01/15-inherit.png)

但是，过度的继承与滥用继承机制，将会导致代码复用的灾难。为代码复用而生的继承为何会导致代码复用的灾难呢？

### 香蕉猴子丛林问题

当有一个新的项目，它让你想起了另一个项目里你很喜欢的那个类。

没问题，复用拯救一切。我只需要把那个类拿过来用就好了。

嗯……其实……不仅是那一个类。还得把父类也拿过来。但……应该就可以了吧。

额……不对，似乎还需要父类的父类……还有……嗯，我们需要所有的祖先类。好吧好吧……搞定了。没问题。

不错。但编译不过，怎么回事？哦我知道了……这个对象还需要另一个对象。所以那个也得拿过来。没问题……

等等……我不仅需要那个对象，还需要那个对象的父类，和父类的父类，和……包含的所有对象的所有祖先……

唉…… 😭

Erlang 的创建者 JoeArmstrong 有句名言：

> 面向对象语言的问题在于，它们依赖于特定的环境。你想要个香蕉，但拿到的却是拿着香蕉的猩猩，乃至最后你拥有了整片丛林。

🙉🙉🙉

### 香蕉猴子丛林的解决方法

这个问题的解决方法是，不要把类层次建得那么深。但如果继承是重用的关键，那么给继承机制添加的任何限制都会限制重用。对吧？

没错。

那面向对象程序员该怎么办？

答案就是引入包含和委托（Contain and Delegate）。一会儿会详细解释。

### 菱形继承问题

考虑如下类继承关系：

![15-2](/images/2019/01/15-2.png)

请看伪代码：

``` java
Class PoweredDevice {
}
Class Scanner inherits from PoweredDevice {
  function start() {
  }
}
Class Printer inherits from PoweredDevice {
  function start() {
  }
}
Class Copier inherits from Scanner, Printer {
}
```

`Scanner` 和`Printer` 同时实现了 `start()` 方法，那么`Copier`到底继承哪一个`start()`呢？
